module DE1_SoC_task2 (
    output logic [6:0] HEX0, HEX1
    ,output logic [9:0] LEDR
    ,input logic [9:0] SW
    ,input logic [3:0] KEY
    ,input logic CLOCK_50
    );
	 
	 assign LEDR[7:0] = 8'b0;

	 logic [7:0] index;
	 double_seg7 addr (
          .HEX0(HEX0)
         ,.HEX1(HEX1)
         ,.num(index)
    );

    binary_search bs (
         .index(index)
        ,.found(LEDR[9])
        ,.not_found(LEDR[8])
        ,.num(SW[7:0])
        ,.start(SW[9])
        ,.clk(CLOCK_50)
        ,.reset(~KEY[0])
    );

endmodule  // DE1_SoC_task2

module DE1_SoC_task2_testbench();

    logic [6:0] HEX0, HEX1;
    logic [9:0] LEDR;
    logic [9:0] SW;
    logic [3:0] KEY;
    logic CLOCK_50, clk;
	 
	 assign CLOCK_50 = clk;
	 
	 DE1_SoC_task2 dut (.*);
	 
	 parameter CLOCK_PERIOD = 100;
	 initial begin
		clk <= 0;
		forever #(CLOCK_PERIOD / 2) clk <= ~clk;
	 end
	 
	 initial begin
		integer i;
		
		@(posedge clk) KEY[0] <= 1'b0; SW[9] <= 1'b0; SW[7:0] <= 8'b00001011;
		@(posedge clk) KEY[0] <= 1'b0;
		@(posedge clk);
		@(posedge clk);
		@(posedge clk) SW[9] <= 1'b1;
		
		for (i = 0; i < 15; i++) begin
			@(posedge clk);
		end
		
		@(posedge clk) SW[9] <= 1'b0; SW[7:0] <= 8'b00110111;
		@(posedge clk);
		@(posedge clk);
		@(posedge clk) SW[9] <= 1'b1;
		
		for (i = 0; i < 15; i++) begin
			@(posedge clk);
		end
		$stop;
	end

endmodule  // DE1_SoC_task2_testbench
